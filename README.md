# PassFriend
is an authentication protocol enabling clients to securely authenticate with multiple services without needing to choose unique password per service

This text formally describes the protocol. The accompanying [Illustration](./Illustration.md) contains a more readily accessible explanation.

# Background
All current authentication protocols require the client to maintain a confidential token for each service that she has been granted access to. Sharing of tokens is stridently discouraged because the client does not trust any server beyond the parameters of the service being provided. This creates the need for the client to maintain a secured map of authentication tokens, unwieldy when the client has multiple possible channels of communication with the servers:  the tokens map must be replicated across all channels, in a fully secure manner. This is only possible for channels where the client endpoints support secure communication. Else the client has to individually replicate the authentication tokens when using new channels. This creates unreasonable burden on the clients’ storage, retrieval and transmission capabilities, as well as creating eavesdropping opportunity for interested observers.

In order to keep the storage and retrieval overhead manageable for clients, it is common for clients to generate the token used for secure communication while services mandate constraints on sequence of symbols comprising acceptable tokens, intended to minimise the chance of a token being duplicated by a stochastic trials process. These constraints are often ill-motivated due to the mismatch between the distribution over alphabets being used by the service to posit pattern constraints, and by a potential attacker to replicate the token (e.g. knowledge of the constraints decreases the entropy of the conditional distribution to be sampled from at each position). Pattern constraints also have the unintended consequence of clients getting overwhelmed by the complexity of storing multiple complex tokens, and reverting to recycling tokens for multiple services. 

# Outline
I propose a flexible protocol for the generation and use of authentication tokens intended to minimise a) storage burden on the client, b) eavesdropping utility during transmission, and c) chance of stochastic inference. I will also provide reference implementation of the software system to generate, manage and transmit these tokens.

The key idea is that instead of storing multiple tokens for different services, the client stores a single long master sequence of symbols with lax constraints on the entropy (thus allowing efficient storage and retrieval). Service-specific tokens are generated from subsequences sampled from this master sequence (response), paired with the sequence of sampled indices (challenge). Both sequences are obfuscated as described below and transmitted to the server as challenge-response pair: authentication is performed by the client requesting the server for a challenge, and transmitting the appropriate response. Subsampling algorithm is designed to generate challenges following a stochastic procedure aiming to maximise response entropy.

The service never gets to know the actual subsequence comprising the response due to obfuscation. Further, obfuscation algorithm utilises a unique identifier for the service, as well as the client identifier specific to the service. So different services do not get the same token, even when the challenge and response are identical. 

The protocol allows multiple challenge-response pairs to be generated for the same service, allowing it to choose unique tokens for proximate sessions order to minimise the potential for eavesdropping. Should a service get compromised, it only needs to alter its unique service id to render the previous tokens database obsolete, and without requiring the client renew tokens for other services. If the client needs to use a new channel for a known service, the challenge-response pairs stored with the service remain valid and can be used to authenticate.

# Caveats
If client loses the stored master sequence, there is no way to authenticate with any service: there would have to be a separate transaction with each service to reestablish trust. However, the premise is that the loss of the single master sequence would be a very unlikely event.

There is also no provision to authenticate the server - it is possible for an imposter with access to the server’s token storage to communicate with the client. There are other well established protocols to guard against this, e.g. certification by trusted identification services.

# Concepts 
1. The key concept ensuring the security of transactions under this protocol is Obfuscation (aka hashing), This is a function that deterministically maps any given sequence to another fixed-length sequence such that the there is no operation to recover the original sequence from the obfuscated sequence.  i.e. <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;\left\|&space;O^{i}(\bar{s})\right\|&space;=i,s_1=s_2\implies&space;O^{i}(\bar{s_1})=O^{i}(\bar{s_2}),\not\exists&space;O':O'(O^{i}(\bar{s}))=\bar{s}" title="\left\| O^{i}(\bar{s})\right\| =i,s_1=s_2\implies O^{i}(\bar{s_1})=O^{i}(\bar{s_2}),\not\exists O':O'(O^{i}(\bar{s}))=\bar{s}" align="middle"/>. 
2. Obfuscation can be reversible if the operation uses an unrelated sequence to derive the obfuscated sequence, and the same key can be used to map the obfuscated sequence to the original sequence (e.g. XOR). i.e. <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;\bar{s_1}=\bar{s_2}&space;\implies&space;R(\bar{s_1},&space;\bar{s_k})=R(\bar{s_2},&space;\bar{s_k}),&space;\space\exists&space;R'&space;:&space;R'(R(\bar{s_i},&space;\bar{s_k}),&space;\bar{s_k})&space;=&space;\bar{s_i}" title="\bar{s_1}=\bar{s_2} \implies R(\bar{s_1}, \bar{s_k})=R(\bar{s_2}, \bar{s_k}), \space\exists R' : R'(R(\bar{s_i}, \bar{s_k}), \bar{s_k}) = \bar{s_i}" align="middle"/>
3. Checksum of a sequence is similar to obfuscation, but the operation _c<sub>j</sub>_, with _j_ being the length of the checksum, is chosen such that <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;\lim_{j\to{min(\|s_1\|,\|s_2\|)}}\Pr(c_j(\bar{s_1})=c_j(\bar{s_2})\mid&space;s_1\neq&space;s_2)\to{0}" title="\lim_{j\to{min(\|s_1\|,\|s_2\|)}}\Pr(c_j(\bar{s_1})=c_j(\bar{s_2})\mid s_1\neq s_2)\to{0}" align="middle"/>
4. Judicious sampling is the operation to select a given number of elements from a sequence subject to the constraint that the distribution of the symbols in the selected subsequence is wider than the distribution of symbols in the sampled sequence  (duplicates permitted). <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;J(\bar{s},m)=\bar{r},\;\;\|\bar{r}\|=m" title="J(\bar{s},m)=\bar{r},\;\;\|\bar{r}\|=m" align="middle"/>, such that <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;\forall{k,j}\;\;H(s_{r_j}\mid\bar{s_{r_{1\cdots&space;j-1}}})\geq&space;H(s_{k}\mid\bar{s_{1\cdots&space;k-1}})" title="\forall{k,j}\;\;H(s_{r_j}\mid\bar{s_{r_{1\cdots j-1}}})\geq H(s_{k}\mid\bar{s_{1\cdots k-1}})" align="middle"/>, where _H_ denotes the entropy of a distribution 
5. Interlacing is the operation to combine k sequences into a single sequence such that the j<sup>th</sup> element of each sequence is placed after the first j-1 elements of all sequences. i.e. <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;Int(\bar{s_1}\cdots\bar{s_k})=\bar{f}\;\;where\;f_j=\bar{s_b}_{\frac{j}{k}},\;b=j\mod&space;k" title="Int(\bar{s_1}\cdots\bar{s_k})=\bar{f}\;\;where\;f_j=\bar{s_b}_{\frac{j}{k}},\;b=j\mod k" align="middle"/>. Interlacing is useful to counter attempts to infer the hashed text by use of rainbow tables.

# Protocol 
## Registration: 
1. Client initiates the registration transaction by transmitting its desired _client_id_ (and optionally the _service_id_) to the server
2. Server checks if this registration request is acceptable, and replies either with denial, or consent accompanied by the public service_id and the maximum and minimum number of challenge-response tokens it expects, _N<sub>x</sub>_ and _N<sub>o</sub>_
3. Upon receipt of consent client transmits to the server a set of <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;N_x&space;\geq&space;N&space;\geq&space;N_o" title="N_x \geq N \geq N_o"/> challenge-response tokens generated following this strategy:
   1. Generate a short checksum from the master sequence <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;q_m=c^k(\bar{M})" title="q_m=c^k(\bar{M_s})"/>
   2. Select a token length _L_ at random between min and max token sequence lengths _L<sub>o</sub>_ and _L<sub>x</sub>_ (_L<sub>o</sub>_ is chosen for sufficiently large number of possible sequences, _L<sub>x</sub>_ for the ease of input) 
   3. Generate a sequence triple <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;(\bar{X},\bar{S},\bar{z})" title="(\bar{X},\bar{S},\bar{z})" /> where <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;\bar{X}=J(\bar{M},L)" title="\bar{X}=J(\bar{M},L)" /> contains _L_ indices in the client’s master sequence <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;\bar{M}" title="\bar{M}" />, <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;\bar{S}=\bar{M}_\bar{X}" title="\bar{S}=\bar{M}_\bar{X}" /> and <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;\bar{z}=c^k(\bar{X})" title="\bar{z}=c^k(\bar{X})"/>
   4. Construct the challenge token <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;C_t=R(\bar{z}&plus;\bar{X_t},O^b(q_m,client\_id,service\_id))" title="C_t=R(\bar{z}+\bar{X_t},O^b(q_m,client\_id,service\_id))" />, i.e. reversible obfuscation of the index list prepended with its checksum, with _b_-length key derived from _q<sub>m</sub>_, _client_id_ and _service_id_.
   5. Construct the response token <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;E_t=O^n(Int(client\_id,\bar{S},service\_id)&plus;\bar{z})" title="E_t=O^n(Int(client\_id,\bar{S},service\_id)+\bar{z})" /> i.e. obfuscation of indexed substring, _client_id & service_id_. _n_ should be reasonably large to avoid collisions
   6. Token _T<sub>t</sub> = &lt;C<sub>t</sub>, E<sub>t</sub>&gt;_
4. Server stores the _client_id_ and the list of tokens as client credentials, and transmits the registration success to the client

## Authentication:
1. Client initiates the authentication transaction by transmitting its _client_id_ (and optionally the _service_id_) to the server
2. Server finds the appropriate stored credentials for the _client_id_, selects a token _T<sub>t</sub> = &lt;C<sub>t</sub>, E<sub>t</sub>&gt;_ from the set of tokens stored as credentials, and transmits _&lt;service_id, C<sub>t</sub>&gt;_ as challenge to the client
3. Upon receipt of C<sub>t</sub>, client validates the server and transmits a response following this strategy:
   1. Invert the obfuscation <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;R'(C_t,O^k(q_m,client\_id,service\_id))=\bar{z}&plus;\bar{X}" title="R'(C_t,O^k(q_m,client\_id,service\_id))=\bar{z}+\bar{X}" />
   2. If <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;\bar{z}\neq&space;c^k(\bar{X})" title="\bar{z}\neq c^k(\bar{X})" />, abort transaction because server can’t be trusted
   3. Transmit the response token <img src="https://latex.codecogs.com/svg.latex?\fn_cm&space;E_t'=O^n(Int(client\_id,\bar{M}_{\bar{X}},service\_id)&plus;\bar{z})" title="E_t'=O^n(Int(client\_id,\bar{M}_{\bar{X}},service\_id)+\bar{z})" />
4. Server authenticates the client if _E'<sub>t</sub> = E<sub>t</sub>_ and transmits the authentication success to the client
5. Obsolescence: Server can respond to the authentication request with an indication that the stored credentials are no longer valid
   * Server responds with an "obsolete" response accompanied by the current _service_id_ and the maximum and minimum number of challenge-response tokens it expects, _N<sub>x</sub>_ and _N<sub>o</sub>_
   * Client has the option of abandoning the authentication attempt, or continue Registration step 3

## Deregister:
1. Client initiates the deregister transaction by transmitting the client_id to the server
2. Server validates the request by continuing the authentication steps 2, 3, 4
3. Server deletes the _client_id_ and the associated tokens from its list of stored credentials and transmits acknowledgement to the client
