## Motivation
Let there be a person Usman with an Internet browser, wishing to communicate securely with multiple web services S1…SN.
As a middle aged man with patchy memory, it is not practical for him to memorise N different login/password combinations.
So he uses a a small number of login/password pairs, and selects from then when signing on to a new service.  
But one day one service got the password data stolen, and advised Usman to change his password.
This was a small problem, until he realised that the hackers use the stolen credentials to try access to many common 
services, leading to his data being compromised on other services also. 

This is a wake up call for Usman. He seeks advice from a more tech-savvy friend, and she advices him to start using a password 
manager. So he considers this option, and realises that as a first step he would need to change passwords on all N services to 
the ones generated by the password manager. This is cumbersome, and frustrating because many services impose arbitrary 
constraints on letter sequences they accept as valid passwords.  
Still better than the alternative. So Usman perseveres, and sets secure passwords on every service. But now he realises 
that this new passwords database has to be replicated on all devices he uses to connect to the Internet. Password manager 
provides a syncing facility to make this easy.  
Usman sometimes uses Internet cafes to access these services, especially when travelling. This is a problem. If he buys a 
smartphone, the problem would be solved since he could store the passwords database on the phone. But he would now have to 
worry about losing the phone, and how he would contact his family, his bank, his insurance etc in that eventuality.  
If only it was possible to conveniently memorise all these credentials!

[PassFriend protocol](./README.md) solves this problem. It requires Usman to memorise only one convenient passphrase, 
without arcane constraints. It only needs to be not ’too’ repetitive, and reasonably long (e.g. twice the length considered 
secure for passwords, so 16-20 alphanumeric characters)

## Illustration
Assume Usman chooses his universal passphrase as "My universal passphrase" (23 characters, 21 alphanumeric), and stores it in 
the PassFriend client Cu running on his computer.  For any supported service Sk, the registration and authentication workflows 
would proceed as follows:

Cu derives 2 universal strings from the universal passphrase:
* M = **"My universal passphrase"**
* Ms = *Myuniversalpassphrase* (```echo $M | sed -E 's/[^[:alnum:]]//g’```)
* qm = *fedd1705* (```printf "%x" `echo $Ms | cksum` ```)

### Registration
1. Cu request Sk to register client_id = *Usman* over a crypographically secured network connection
2. Sk verifies that it has no other Usman registered, and responds with service_id = *Service_k_uuid*, Nt = 3, nt = 1.
   - service_id is expected to be unique to the service (e.g. URI). Nt and nt specify the maximum and minimum number of authentication tokens the service will accept. More critical services, e.g. banking, taxes etc should specify higher numbers 
3. Cu generates 2 auth tokens by sampling Ms non-randomly (random sampling will render sampled tokens susceptible to 
frequency analysis). Sampling can duplicate indices, and each index list need not have the same length.
   - choose index list [1,3,6,10,15,21] and for illustration purposes randomly permute it twice to get [6,10,3,15,1,21] and 
   [15,1,21,6,3,10]. Corresponding subsequences are *vausMe* and *sMevua*. Cu could choose index lists to ensure distinct 
   subsequences.
   - Make challenge tokens by representing indices as 2 hex numbers and appending respective checksums: *060a030f0115:ac7e*, 
   *0f011506030a:1f93*  
   - Make encryption key qkey from qm, client_id, service_id, e.g. qkey = **PBKDF2**(*fedd1705UsmanService_k_uuid*)
   and symmetrically encrypt the sequences with qkey (maybe using Twofish): C1 = *DE81DB84D99E74F5* and C2 = *D78ACD8DDB81C718*
   - Make response tokens by interlacing service_id and client_id with subsequences, appending index-list checksums, and computing cryptographic hashes:  
   R1 = **SHA2**(*UvSsaemurasvnMiece_k_uuid:ac7e*) and R2 = **SHA2**(*UsSsMemeravvnuiace_k_uuid:1f93*)
4. Cu transmits token pairs (C1, R1) and (C2, R2) to the server. Server stores these as credentials for user Usman and 
acknowledges the receipt to the client.

### Authentication
1. Cu requests Sk to authenticate user Usman over a crypographically secured network connection
2. Sk verifies that Usman is a registered user, and selects a token pair (Cj, Rj) from the LRU cache of corresponding 
credentials. Transmits Cj = *DE81DB84D99E74F5* and service_id = *Service_k_uuid* to Cu
3. Cu transmits the appropriate response to the challenge Cj:
   - Make encryption key qkey from qm, client_id, service_id, e.g. qkey = **PBKDF2**(*fedd1705UsmanService_k_uuid*)
   - Decrypt Cj with key qkey to get 060a030f0115:ac7e
   - Verify that the part after the last delimiter (*ac7e*) is the checksum for the indices string (*060a030f0115*). If not, abort authentication.
   - Construct subsequence by sampling Ms at index list denoted by bytes in the string [6, 10, 3, 15, 1, 21]: *vausMe*
   - R’j = **SHA2**(*UvSsaemurasvnMiece_k_uuid:ac7e*)
4. Sk authenticates Usman if R’j = Rj and starts the transaction with Cu

## Notes
1. The challenge and response both cannot be constructed without the master passphrase 
2. If multiple users have selected the same master passphrase, use of client_id ensures that server is not aware of this
3. If an interloper tries to deduce the master passphrase by impersonating a server, the challenges will be declined because 
checksum of index list will not match
4. Response construction utilises interlace operation to combine three strings as countermeasure against attempts to infer 
portions of the master passphrase via related-key attacks. Appended checksum for the challenge string ensures response tokens are different even for identical sampled subsequences.
5. If a service gets compromised and credentials are leaked, the user’s credentials are compromised only on that service. Other 
services are not affected because the same challenge from different services authenticates with different responses. 
6. The protocol mandates interactive clients implementation to support two modes of operation, trusted and untrusted:
   - The illustration above assumes that the user is able to trust the client implementation to securely store her master 
   password, allowing automated negotiation for authentication as well as registrations.
   - User is also able to securely authenticate on untrusted client implementations (e.g. on computers in Internet cafes): the 
   user keeps a copy of the passphrase checksum (qm), and enters it manually when challenged by the server. This lets the 
   client query the user for characters at the requested indices to construct the response.
   - Untrusted clients are able to register with new services if the user provides the number of characters in the master 
   passphrase (|Ms|), though this is suboptimal because the client will be able to infer the passphrase from multiple 
   subsequences provided. Also the user can’t trust the client to request more subsequences than the server requests.
